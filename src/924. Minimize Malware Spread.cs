public class Solution {
    // Union Find
    // T: O(VLogE)
    public int MinMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.Length;
        int[] roots = new int[n];
        for (int i = 0; i < n; i++) roots[i] = i;
        // Union
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; j++) {
                int pi = UnionFind(roots, i);
                int pj = UnionFind(roots, j);
                if (graph[i][j] == 1) roots[pj] = pi;
            }
        }
        Array.Sort(initial);
        int[] cnt = new int[n];
        int[] idToMalwareCnt = new int[n];
        for (int i = 0; i < n; i++) cnt[UnionFind(roots, i)]++;
        foreach (int t in initial) idToMalwareCnt[UnionFind(roots, t)]++;
        int minCnt = Int32.MinValue;
        // if each malware node affacts the same,
        // return 1st one.
        int ans = initial[0];
        foreach (int t in initial) {
            int rt = UnionFind(roots, t);
            // each root has > 1 malware, removing one does not help
            if (idToMalwareCnt[rt] == 1 && cnt[rt] > minCnt) {
                ans = t;
                minCnt = cnt[rt];
            }
        }
        return ans;
    }
    int UnionFind(int[] roots, int x) {
        return roots[x] == x ? x : roots[x] = UnionFind(roots, roots[x]);
    }
    // BFS
    // T: O(n^3) => TLE
    public int MinMalwareSpread1(int[][] graph, int[] initial) {
        Array.Sort(initial);
        int ans = -1;
        int minCnt = Int32.MaxValue;
        int n = graph.Length;
        foreach (int t in initial) {
            int[] bad = new int[n];
            var q = new Queue<int>();
            foreach (int i in initial) { 
                if (i != t) {
                    q.Enqueue(i); bad[i] = 1;
                }
            }
            while (q.Any()) {
                int x = q.Dequeue();
                for (int j = 0; j < n; j++) {
                    if (graph[x][j] == 0 || bad[j] == 1) continue;
                    bad[x] = 1;
                    q.Enqueue(j);
                }
            }
            int curCnt = new List<int>(bad).Count(x => x == 1);
            if (curCnt < minCnt) {
                ans = t;
                minCnt = curCnt;
            }
        }
        return ans;
    }
}
